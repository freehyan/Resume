
# DAIS (Deferred Attribute Interpolation Shading)

### Visibility Sample

可见性采样阶段: 和传统延迟着色相同，DAIS只关心可见性表面的信息。为了确定可见性三角片元的ID，这里需要使用**两个**几何pass，第一个几何pass保存场景的深度值，第二个几何pass还需要加入几何着色器，并在片元着色器中打开提前深度测试，保证只有深度值等于当前深度缓冲区的片元才能通过深度测试。这遍pass	的几何着色器组合三个顶点形成一个三角图元，并针对三角图片产生一个唯一的三角形ID。

### Memoization cache

算法另外一个实现关键点是MC的实现，引用了[Liktor and Dachsbacher 12]的论文实现。 这篇论文思想是使用visibility buffer和triangle buffer代替传统Geometry buffer来减少开销，那么怎么给一个三角形分配内存地址来保存数据？	MC的作用就是通过image缓存进行三角形物理地址分配，建立三角形ID和物理地址的映射关系。

MC主要通过两个ImageBuffer实现，一个是**Lock Buffer**进行临界区资源的同步访问，因为统一三角性经过光栅化会得到多个片元，在GPU中是并行执行的。所以为了避免统一三角形内不同片元都分配内存然后进行后期的属性偏导数计算。所以给统一三角形内的不同片元进行同步控制，不过这里和传统CPU加锁机制有点不一样，GPU线程会取更新后lock缓存的值。 而**Cache Buffer**表示三角形buffer的缓存入口地址，为了节约内存，这里会保存两个缓存入口。
其中**Cache Buffer**的作用是如果Cache Buffer中没有包含请求三角形ID，将会同步访问cache为其分配物理内存地址。如果有，则返回已经分配好的内存地址。

* 其中**Lock Buffer** 只有LOCKED和UNLOCKED两个状态，通过**imageAtomicExchange**子函数进行加锁操作；
* 注意**Cache Buffer**存两个cache bucket缓存入口，是先进先出FIFO的策略。


### Computing Partial Derivatives of Triangle Attributes

首先需考虑的是三角形三个顶点如果有一个顶点或两个顶点在视景体范围外，怎么保存当前被clipping三角形的偏导数。其实根据光栅化的原理，三角形进行属性插值是具有线性性质的。所以这里会收缩三角形外部的顶点到视景体边缘线。

其次三角形属性的偏导数应该保存哪个位置的属性值。 三角形的三个三维顶点都会投影到屏幕上， 或者根据二维的三角形来说。三角形的属性肯定是根据三个顶点的属性计算得到的，而三角形的重心正好可以表达插值这个性质。 而重心坐标的偏导数可以根据公式求出，在根据求出的重心坐标偏导数，求出三角形的属性偏导数。最后计算原点的属性值，作为一个固定点的基本值，后面的属性计算以此为参考点。 

* 计算三角形属性的偏导数的目的是为了作为属性插值的输入

### Attribute Interpolation Using Partial Derivatives

计算输入三角形片元点的位置，取出**Triangle buffer**的保存的原点属性值。然后根据当前点离原点的△x和△y，以及基本参考点的属性点计算当前片元的属性。
不过需要注意的是，因为存在透视投影的原因，所以这里需要进行**透视矫正**，即最后结果还需要除以w的倒数。

### 问题：

* 主要解决什么问题？

	传统延迟着色中G-Buffer需保存着色需要的各种几何信息，所以显存开销比较大。DAIS可以减少延迟着色中内存开销过大的问题，并且在效率上也能提高。
	内存开销可以减少50%。

* 怎么解决这个问题？
	
	通过建立Visibility Buffer和Triangle Buffer去代替Geometry Buffer，以前几何缓存是保存逐片元信息。而现在的两个是保存逐三角形信息，然后再后处理阶段再通过偏导数进行属性插值得到每个片元的信息。从而能减少开销。

* 具体实现步骤？
	* 两个Geometry Pass保证可见性采样
	* 几何着色器分配唯一三角形ID，实现MC建立三角形ID和地址的映射关系
	* 计算三角形的偏导数保存在刚刚分配的地址中，需保证每个三角形只执行一次，只保存一次
	* 根据三角形偏导数信息，可以计算每个三角形片元的几何信息，从而进行shading

* 遇到的困难？

	* 目前效率低下，没有达到的执行效率？ 猜测是因为MC的**LOCK BUFFER**导致，优化中；
	* 论文中还提到Multi-shading，目前没有思路
	* 怎么保存material进行属性插值？ 可通过NVIDIA的bindless纹理机制解决

