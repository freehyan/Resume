
# Anti-Aliasing

## 反走样

走样，在图形的绘制过程中，图形边缘的非连续状态的失真现象，直观看上去就是图形边缘呈锯齿状，而从信号处理的角度就是图形信息丢失。 
所以，反走样就是消除计算机图形学中物体边缘的锯齿现象。

## 基于延迟着色的多重采样反走样

* 多重采样，使用多个采样点决定多边形覆盖范围，每个像素执行一次片元着色器，片元的颜色由子采样样本的颜色平均计算得出。 
* 多重采样和延迟着色（Deferred Shading）并不兼容，因为场景信息被渲染至G-Buffer中，不能通过硬件的方式决定像素是边缘。

####  算法步骤

* 复杂像素检测
	* 通过内置变量**gl_SampleMaskIn**计算当前片元的“像素覆盖码(Coverage Mask)”。此方法的缺点是错标非边缘的像素为复杂片元，因为它依赖于基础几何而不是**屏幕空间不连续性**。
	* 计算法线，颜色，深度的不连续性，比设定阈值大即为复杂像素。优点在于只产生边缘复杂像素，

---

* 复杂像素的分离pass

通过像素掩码来区分复杂像素和正常像素，如果像素是复杂情况，执行超采样然后平均结果输出。此缺点是线程并发性，对于包含在在一个线程组的像素，只能等
复杂像素执行完超采样才能执行简单像素。 
	
1. 可通过分离pass，第一个渲染简单像素，第二个pass渲染复杂像素。不过需引进模板缓冲，这也是一个额外开销。
2. 可基于硬件的超采样对于复杂像素，不同于一个shader调用执行shading多个样本。所以设计片元shader执行per-sample level方法。需打开
	开关gl_SampleId, GL_SAMPLE_SHADING.

---
* 自适应pass

因为sample采样点对应的三角形图元可能对应多个样本点，所以没必要这些样本都去执行shading，只需要执行一次，而把它们输出所占比重求出即可。
使用coverage mask计算每个像素相同掩码值的数量。


## 问题

* 多重采样为什么能解决反走样问题？

首先需要知道光栅化原理，图形硬件光栅化以后像素没覆盖到像素中心，那么此像素不着色；相反着色。这种离散采样来来表达连续信号造成了走样效果，最简单有效方式就是进行超级采样，但是会增加开销。而多重采样在一个像素中会增加子像素的采样，
根据子像素颜色平均化来解决走样问题。

* 为什么延迟着色不支持反走样？

因为延迟着色不再具有场景几何信息，不能通过硬件光栅化得到片元的三角形覆盖情况，所以无法利用此硬件多重采样方式特性。


## 形态抗锯齿反走样

相比于多重采样反走样，MLAA是后处理方法，没有消耗N倍的显存空间。针对边缘像素做了滤波处理，减轻了走样效果。

计算当前像素在边缘线的左右距离，然后根据像素在边缘线的位置得到相应的面积权重，而面积可通过预计算放到一张二维纹理中，面积纹理的uv编码成到左右垂直边缘的距离。通过向北方和西方两个方向确定边缘线的模式。

#### 算法步骤

* 边缘检测

计算当前像素的luminance值，根据相邻像素点积差得到边缘像素，或者也可以通过深度偏差值进行计算。

* 计算混合权重

	1. 计算边缘线距离: 通过迭代方式，向左右上下，设定设定终止次数。终止条件是下一个像素的值在此线段方向小于1。 利用硬件双边滤波优势，一次
	取两个像素提高实时性。但是也引起了一个错误问题，在0.5的情况是不能确定是哪个像素已到终点了。其次在遇到垂直线时也应该终止，这些情况在实际情况对结果并无直接表面影响，故忽略。
	
	2. 获取交叉边缘：同样利用双边滤波特性，一次取边缘的两个方向。但是交叉边缘存在四个情况，所以区别每天边实际值。我们用0:25的偏移量来查询，一条边出现时，值等于1.0。

	3. 预计算面积: 面积纹理被划分为9*9的子纹理组用来确定相应的模式，uv坐标代表到线端点的距离，而e1,e2代表获取的交叉边缘。双边滤波值e1,e2装换到[0,4],值2对应0.5但是实际情况不会发生。

---
* 相邻像素混合

根据权重纹理，取出当前像素和四个周边像素上下左右的权重值，求出最终的平均和。

#### 算法展望

算法是后处理算法，针对低分辨的图像，如果边缘检测不能很好处理的话，那么会过度模糊纹理其他非边缘部分，造成最终结果纹理模糊效果。