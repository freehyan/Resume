
# Atmosphere Scattering

大气散射现象产生是因为光子和传输介质的粒子交互引起。 当和介质粒子发生碰撞时，光子会发生吸收和漫发射。所以分析来建立能量模型：

** L(incoming) = L(transmitted) + L(absorbed) + L(scattered) **

* Transmittance：在入射光方向光传输通过的比例
* Scattering：光子和粒子交互后向四周发射能量
* Absorbtion：光子的一部分能量转换为粒子内部

### 体积纹理布局

立方体数据布局：容易时间采样，但光线追踪通过体积要求多次采样，慢和走样

We:布局对齐相机视镜体，使用NDC映射视镜体到立方体，深度片为指数深度分布;

160*90*64=1280*720,每个cell光照一次

雾的范围：50-128米

### Beer-Lambert law

比尔朗伯定律很好地描述了光的散射物理定律，入射光的消失(extinction)。 定律定义了透射比(Transmittance)的值，是一个A到B的指数级函数。

* 瑞利散射(Rayleigh scattering)： 被参与介质中非常小的粒子所影响，会产生蓝色的天空效果，是各向同性的性质。与波长相关，波长越短散射越强，而对吸收则忽略不计。

* 米散射(Mie scattering)：参与介质的大颗粒子，如气溶胶和灰尘，有各项异性的性质，和比较高的吸收比例。

* 相位函数(Phase function)：描述在所有方向，多少光被散射。它是关于光的方向和外散射方向的角度函数，满足能量守恒定律，即所有方向的积分值等于1。

* 亨耶-格林斯坦(Henyey-Greenstein phase function): 模拟近似的各向异性米散射，有一些优势：
	* 有效的运行时计算
	* 很容易扩展为球谐函数(spherical harmonics)
	* 支持变化的各向异性因子

## 算法步骤

![][1]

* 每个体素单元执行光照和阴影计算
* 并行估计参与介质的密度
* 用前两步的体积纹理执行2D光线追踪算法
* 最后使用PS应用到前向或延迟的着色物体对象上

# Estimation of Participating Media Scattering Coefficients

* 计算体积纹理体素的世界坐标
* 计算slice的厚度
* 根据世界坐标计算粒子密度
* 计算相位函数
* 计算太阳光的辐照度（辐照度*相位函数）
* 最终的内散射是**外出的辐照度和散射系数的点积**，而消光系数是**散射系数和吸收系数**的和。

# Ray Marching and Solving the Scattering Equation

在view方向上使用先前已经计算好的内散射光，通过计算着色器以体积纹理slice的方式循环执行2D线程组操作。 计算着色器在view方向累计散射系数和内散射光照：

* 读取在slice N的内散射光照和消光系数，以0值开始
* 添加消光系数到累计的衰减系数上，用比尔朗伯定律计算透射比
* 在当前slice片上，应用透射比到内散射光照，累计内散射结果到RGB通道
* 写值到另一个相同位置体积纹理中，RGB值表示累计的内散射光照，alpha表示透射比
* 增加N值继续重复处理

![][2]

# Applying the Effect on Deferred- or Forward-Shaded Objects

因为散射值已经被写入体积纹理中，所以物体的像素颜色的表达式为：

```c++
ShadedPixelColor = ShadedPixelColor × Transmittance + InScattering
```
![][3]


### 问题

* 为什么需要模拟大气散射？

	因为现实生活中的许多现象都需要大气散射这个物理效果。比如天空颜色，雾，云，光束，god rays，体积阴影。

* 为什么要在游戏中模拟这些效果？

	* 需要正确复制真实性
	* 帮助玩家感知对象之间的距离
	* 在艺术上建立场景的氛围和情绪

* 为什么不使用普通的2D ray marching方法？
	
	* 没有基于物理实现和不支持长范围的体积雾 
	* 没有有效使用GPU并行的能力，是一种坏的循环方式
	* 对于极限采样的限制:1) 没有变化的粒子密度 2）不支持多光源
	* 以前的解决方案是后处理方法，不能处理前向着色物体，比如透明物理和粒子效果
	* 较小分辨率的ray marching方法，会产生下采样，走样，边缘人工制品




[1]: fog_1.png
[2]: fog_2.png
[3]: fog_3.png